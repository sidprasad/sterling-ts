import React from 'react';
import { useSterlingSelector } from '../../state/hooks';
import { selectActiveDatum } from '../../state/selectors';
import VizConstructor from './viz-ir-constructor/VizConstructor';
import { LocalNextExpressionIdProvider } from './interp-viz-generator/LocalNextExpressionIdProvider';
import { ForgeUtil } from './forge-evaluator';
import { extractPredicates } from './predicate-extractor/predicate-extractor';
import { ForgePredUtil } from './forge-evaluator-pred';

const JsonView = () => {
  const datum = useSterlingSelector(selectActiveDatum);
  if (!datum) return null;

  console.log('datum:', datum);
  // console.log('datum.data', datum.data);

  // sample data
  // const content = '"#lang forge\r&#xA;// #lang forge/bsl\r&#xA;\r&#xA;/*\r&#xA;  Tic-tac-toe boards, moves, and games\r&#xA;  Taken from CSCI 1710 Livecode\r&#xA;*/\r&#xA;\r&#xA;abstract sig Player {}\r&#xA;one sig X, O extends Player {}\r&#xA;\r&#xA;sig Board {\r&#xA;    board: pfunc Int -&amp;gt; Int -&amp;gt; Player\r&#xA;}\r&#xA;\r&#xA;pred wellformed[b: Board] {\r&#xA;    all row, col: Int | {\r&#xA;        (row &amp;lt; 0 or row &amp;gt; 2 or col &amp;lt; 0 or col &amp;gt; 2) implies\r&#xA;        no b.board[row][col]\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;pred Xturn[b: Board] {\r&#xA;    -- same number of X and O on board\r&#xA;    #{row, col: Int | b.board[row][col] = X} = \r&#xA;    #{row, col: Int | b.board[row][col] = O}\r&#xA;}\r&#xA;\r&#xA;pred Oturn[b: Board] {\r&#xA;    #{row, col: Int | b.board[row][col] = X} = \r&#xA;    add[#{row, col: Int | b.board[row][col] = O}, 1]\r&#xA;}\r&#xA;pred balanced[b: Board] {\r&#xA;    Oturn[b] or Xturn[b]\r&#xA;}\r&#xA;\r&#xA;pred winRow[b: Board, p: Player] {\r&#xA;    some row: Int | {\r&#xA;        b.board[row][0] = p\r&#xA;        b.board[row][1] = p\r&#xA;        b.board[row][2] = p\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;pred winCol[b: Board, p: Player] {\r&#xA;    some col: Int | {\r&#xA;        b.board[0][col] = p\r&#xA;        b.board[1][col] = p\r&#xA;        b.board[2][col] = p\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;\r&#xA;pred winner[b: Board, p: Player] {\r&#xA;    winRow[b, p]\r&#xA;    or \r&#xA;    winCol[b, p]\r&#xA;    or {\r&#xA;      b.board[0][0] = p\r&#xA;      b.board[1][1] = p\r&#xA;      b.board[2][2] = p\r&#xA;    } or {\r&#xA;      b.board[0][2] = p\r&#xA;      b.board[1][1] = p\r&#xA;      b.board[2][0] = p\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;-------------------------------------------------\r&#xA;-- Games\r&#xA;\r&#xA;pred starting[b: Board] {\r&#xA;    all row, col: Int | \r&#xA;        no b.board[row][col]\r&#xA;}\r&#xA;\r&#xA;pred move[pre: Board, post: Board, row: Int, col: Int, p: Player] {\r&#xA;    -- GUARD (what needs to hold about the pre-state?)\r&#xA;    no pre.board[row][col] -- no move already there\r&#xA;    p = X implies Xturn[pre] -- appropriate turn\r&#xA;    p = O implies Oturn[pre]  \r&#xA;    -- What else might we want to add here?\r&#xA;\r&#xA;    -- ACTION (what does the post-state then look like?)\r&#xA;    post.board[row][col] = p\r&#xA;    all row2: Int, col2: Int | (row!=row2 or col!=col2) implies {                \r&#xA;        post.board[row2][col2] = pre.board[row2][col2]     \r&#xA;    }  \r&#xA;}\r&#xA;\r&#xA;one sig Game {\r&#xA;  initialState: one Board,\r&#xA;  next: pfunc Board -&amp;gt; Board\r&#xA;}\r&#xA;\r&#xA;pred traces {\r&#xA;    starting[Game.initialState]\r&#xA;    all b: Board | some Game.next[b] implies {\r&#xA;        some row, col: Int, p: Player | \r&#xA;            move[b, Game.next[b], row, col, p]\r&#xA;    }\r&#xA;    -- Is there anything else we might want to add, here?\r&#xA;}\r&#xA;\r&#xA;run {\r&#xA;    all b: Board | wellformed[b]\r&#xA;    traces\r&#xA;} for exactly 7 Board, 4 Int for {next is linear}\r&#xA;\r&#xA;\r&#xA;// #lang froglet \r&#xA;\r&#xA;// abstract sig Player {}\r&#xA;// one sig X, O extends Player {}\r&#xA;\r&#xA;// sig Board {\r&#xA;//   board : pfunc Int -&amp;gt; Int -&amp;gt; Player \r&#xA;// }\r&#xA;\r&#xA;// -- a Board is well-formed if and only if:\r&#xA;// pred wellformed[s: Board] {\r&#xA;//   -- row and column numbers used are between 0 and 2, inclusive  \r&#xA;//   all row, col: Int | {\r&#xA;//     (row &amp;lt; 0 or row &amp;gt; 2 or col &amp;lt; 0 or col &amp;gt; 2) \r&#xA;//       implies no s.board[row][col]      \r&#xA;//   }\r&#xA;// }\r&#xA;\r&#xA;// run { some b : Board | wellformed[b] }\r&#xA;\r&#xA;// // pred starting[s: Board] {\r&#xA;// //   all row, col: Int | \r&#xA;// //     no s.board[row][col]\r&#xA;// // }\r&#xA;\r&#xA;// // pred XTurn[s: Board] {\r&#xA;// //   #{row, col: Int | s.board[row][col] = X} =\r&#xA;// //   #{row, col: Int | s.board[row][col] = O}\r&#xA;// // }\r&#xA;\r&#xA;// // pred OTurn[s: Board] {\r&#xA;// //   #{row, col: Int | s.board[row][col] = X} =\r&#xA;// //   add[#{row, col: Int | s.board[row][col] = O}, 1]\r&#xA;// // }\r&#xA;\r&#xA;// // pred winRow[s: Board, p: Player] {\r&#xA;// //   -- note we cannot use `all` here because there are more Ints  \r&#xA;// //   some row: Int | {\r&#xA;// //     s.board[row][0] = p\r&#xA;// //     s.board[row][1] = p\r&#xA;// //     s.board[row][2] = p\r&#xA;// //   }\r&#xA;// // }\r&#xA;\r&#xA;// // pred winCol[s: Board, p: Player] {\r&#xA;// //   some column: Int | {\r&#xA;// //     s.board[0][column] = p\r&#xA;// //     s.board[1][column] = p\r&#xA;// //     s.board[2][column] = p\r&#xA;// //   }      \r&#xA;// // }\r&#xA;\r&#xA;// // pred winner[s: Board, p: Player] {\r&#xA;// //   winRow[s, p]\r&#xA;// //   or\r&#xA;// //   winCol[s, p]\r&#xA;// //   or \r&#xA;// //   {\r&#xA;// //     s.board[0][0] = p\r&#xA;// //     s.board[1][1] = p\r&#xA;// //     s.board[2][2] = p\r&#xA;// //   }\r&#xA;// //   or\r&#xA;// //   {\r&#xA;// //     s.board[0][2] = p\r&#xA;// //     s.board[1][1] = p\r&#xA;// //     s.board[2][0] = p\r&#xA;// //   }  \r&#xA;// // }\r&#xA;\r&#xA;// // pred balanced[s: Board] {\r&#xA;// //   XTurn[s] or OTurn[s]\r&#xA;// // }\r&#xA;\r&#xA;// // // run { all b: Board | wellformed[b] and balanced[b]} for exactly 1 Board \r&#xA;\r&#xA;// // // run {\r&#xA;// // //   all b : Board | {\r&#xA;// // //     wellformed[b]\r&#xA;// // //     balanced[b]\r&#xA;// // //     winner[b, X]\r&#xA;// // //   }\r&#xA;// // // } for exactly 1 Board\r&#xA;\r&#xA;// // pred move[pre: Board, post: Board, row: Int, col: Int, p: Player] {\r&#xA;// //   -- guard:\r&#xA;// //   no pre.board[row][col]   -- nobody\'s moved there yet\r&#xA;// //   p = X implies XTurn[pre] -- appropriate turn\r&#xA;// //   p = O implies OTurn[pre]  \r&#xA;// //   row &amp;gt;= 0 and row &amp;lt;= 2    -- row number is valid\r&#xA;// //   col &amp;gt;= 0 and col &amp;lt;= 2    -- column number is valid\r&#xA;  \r&#xA;// //   -- action:\r&#xA;// //   post.board[row][col] = p\r&#xA;// //   all row2: Int, col2: Int | ((row!=row2) or (col!=col2)) implies {        \r&#xA;// //      post.board[row2][col2] = pre.board[row2][col2]     \r&#xA;// //   }  \r&#xA;// // }\r&#xA;\r&#xA;// // // run {\r&#xA;// // //   some pre, post: Board | {\r&#xA;// // //     wellformed[pre]\r&#xA;// // //     not wellformed[post]\r&#xA;// // //     some row, col: Int, p: Player | {\r&#xA;// // //       move[pre, post, row, col, p]\r&#xA;// // //     }\r&#xA;// // //    }\r&#xA;// // // } for 2 Board\r&#xA;\r&#xA;\r&#xA;// // one sig Game {\r&#xA;// //   initialState: one Board,\r&#xA;// //   next: pfunc Board -&amp;gt; Board\r&#xA;// // }\r&#xA;\r&#xA;// // pred traces {\r&#xA;// //     -- The trace starts with an initial state\r&#xA;// //     starting[Game.initialState]\r&#xA;// //     no sprev: Board | Game.next[sprev] = Game.initialState\r&#xA;// //     -- Every transition is a valid move\r&#xA;// //     all s: Board | some Game.next[s] implies {\r&#xA;// //       some row, col: Int, p: Player |\r&#xA;// //         move[s, Game.next[s], row, col, p]\r&#xA;// //     }\r&#xA;// // }\r&#xA;\r&#xA;// // pred dummy {\r&#xA;// // 2 > 1\r&#xA; #Board = 7\r&#xA;// // }\r&#xA;// // run {\r&#xA;// //   traces\r&#xA;// // } for exactly 10 Board for {next is linear}\r&#xA;"';
  const content = '"#lang forge\r&#xA;// #lang forge/bsl\r&#xA;\r&#xA;/*\r&#xA;  Tic-tac-toe boards, moves, and games\r&#xA;  Taken from CSCI 1710 Livecode\r&#xA;*/\r&#xA;\r&#xA;abstract sig Player {}\r&#xA;one sig X, O extends Player {}\r&#xA;\r&#xA;sig Board {\r&#xA;    board: pfunc Int -&amp;gt; Int -&amp;gt; Player\r&#xA;}\r&#xA;\r&#xA;pred wellformed[b: Board] {\r&#xA;    all row, col: Int | {\r&#xA;        (row &amp;lt; 0 or row &amp;gt; 2 or col &amp;lt; 0 or col &amp;gt; 2) implies\r&#xA;        no b.board[row][col]\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;pred Xturn[b: Board] {\r&#xA;    -- same number of X and O on board\r&#xA;    #{row, col: Int | b.board[row][col] = X} = \r&#xA;    #{row, col: Int | b.board[row][col] = O}\r&#xA;}\r&#xA;\r&#xA;pred Oturn[b: Board] {\r&#xA;    #{row, col: Int | b.board[row][col] = X} = \r&#xA;    add[#{row, col: Int | b.board[row][col] = O}, 1]\r&#xA;}\r&#xA;pred balanced[b: Board] {\r&#xA;    Oturn[b] or Xturn[b]\r&#xA;}\r&#xA;\r&#xA;pred winRow[b: Board, p: Player] {\r&#xA;    some row: Int | {\r&#xA;        b.board[row][0] = p\r&#xA;        b.board[row][1] = p\r&#xA;        b.board[row][2] = p\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;pred winCol[b: Board, p: Player] {\r&#xA;    some col: Int | {\r&#xA;        b.board[0][col] = p\r&#xA;        b.board[1][col] = p\r&#xA;        b.board[2][col] = p\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;\r&#xA;pred winner[b: Board, p: Player] {\r&#xA;    winRow[b, p]\r&#xA;    or \r&#xA;    winCol[b, p]\r&#xA;    or {\r&#xA;      b.board[0][0] = p\r&#xA;      b.board[1][1] = p\r&#xA;      b.board[2][2] = p\r&#xA;    } or {\r&#xA;      b.board[0][2] = p\r&#xA;      b.board[1][1] = p\r&#xA;      b.board[2][0] = p\r&#xA;    }\r&#xA;}\r&#xA;\r&#xA;-------------------------------------------------\r&#xA;-- Games\r&#xA;\r&#xA;pred starting[b: Board] {\r&#xA;    all row, col: Int | \r&#xA;        no b.board[row][col]\r&#xA;}\r&#xA;\r&#xA;pred move[pre: Board, post: Board, row: Int, col: Int, p: Player] {\r&#xA;    -- GUARD (what needs to hold about the pre-state?)\r&#xA;    no pre.board[row][col] -- no move already there\r&#xA;    p = X implies Xturn[pre] -- appropriate turn\r&#xA;    p = O implies Oturn[pre]  \r&#xA;    -- What else might we want to add here?\r&#xA;\r&#xA;    -- ACTION (what does the post-state then look like?)\r&#xA;    post.board[row][col] = p\r&#xA;    all row2: Int, col2: Int | (row!=row2 or col!=col2) implies {                \r&#xA;        post.board[row2][col2] = pre.board[row2][col2]     \r&#xA;    }  \r&#xA;}\r&#xA;\r&#xA;one sig Game {\r&#xA;  initialState: one Board,\r&#xA;  next: pfunc Board -&amp;gt; Board\r&#xA;}\r&#xA;\r&#xA;pred traces {\r&#xA;    starting[Game.initialState]\r&#xA;    all b: Board | some Game.next[b] implies {\r&#xA;        some row, col: Int, p: Player | \r&#xA;            move[b, Game.next[b], row, col, p]\r&#xA;    }\r&#xA;    -- Is there anything else we might want to add, here?\r&#xA;}\r&#xA;\r&#xA;run {\r&#xA;    all b: Board | wellformed[b]\r&#xA;    traces\r&#xA;} for exactly 7 Board, 4 Int for {next is linear}\r&#xA;\r&#xA;\r&#xA;// #lang froglet \r&#xA;\r&#xA;// abstract sig Player {}\r&#xA;// one sig X, O extends Player {}\r&#xA;\r&#xA;// sig Board {\r&#xA;//   board : pfunc Int -&amp;gt; Int -&amp;gt; Player \r&#xA;// }\r&#xA;\r&#xA;// -- a Board is well-formed if and only if:\r&#xA;// pred wellformed[s: Board] {\r&#xA;//   -- row and column numbers used are between 0 and 2, inclusive  \r&#xA;//   all row, col: Int | {\r&#xA;//     (row &amp;lt; 0 or row &amp;gt; 2 or col &amp;lt; 0 or col &amp;gt; 2) \r&#xA;//       implies no s.board[row][col]      \r&#xA;//   }\r&#xA;// }\r&#xA;\r&#xA;// run { some b : Board | wellformed[b] }\r&#xA;\r&#xA;// // pred starting[s: Board] {\r&#xA;// //   all row, col: Int | \r&#xA;// //     no s.board[row][col]\r&#xA;// // }\r&#xA;\r&#xA;// // pred XTurn[s: Board] {\r&#xA;// //   #{row, col: Int | s.board[row][col] = X} =\r&#xA;// //   #{row, col: Int | s.board[row][col] = O}\r&#xA;// // }\r&#xA;\r&#xA;// // pred OTurn[s: Board] {\r&#xA;// //   #{row, col: Int | s.board[row][col] = X} =\r&#xA;// //   add[#{row, col: Int | s.board[row][col] = O}, 1]\r&#xA;// // }\r&#xA;\r&#xA;// // pred winRow[s: Board, p: Player] {\r&#xA;// //   -- note we cannot use `all` here because there are more Ints  \r&#xA;// //   some row: Int | {\r&#xA;// //     s.board[row][0] = p\r&#xA;// //     s.board[row][1] = p\r&#xA;// //     s.board[row][2] = p\r&#xA;// //   }\r&#xA;// // }\r&#xA;\r&#xA;// // pred winCol[s: Board, p: Player] {\r&#xA;// //   some column: Int | {\r&#xA;// //     s.board[0][column] = p\r&#xA;// //     s.board[1][column] = p\r&#xA;// //     s.board[2][column] = p\r&#xA;// //   }      \r&#xA;// // }\r&#xA;\r&#xA;// // pred winner[s: Board, p: Player] {\r&#xA;// //   winRow[s, p]\r&#xA;// //   or\r&#xA;// //   winCol[s, p]\r&#xA;// //   or \r&#xA;// //   {\r&#xA;// //     s.board[0][0] = p\r&#xA;// //     s.board[1][1] = p\r&#xA;// //     s.board[2][2] = p\r&#xA;// //   }\r&#xA;// //   or\r&#xA;// //   {\r&#xA;// //     s.board[0][2] = p\r&#xA;// //     s.board[1][1] = p\r&#xA;// //     s.board[2][0] = p\r&#xA;// //   }  \r&#xA;// // }\r&#xA;\r&#xA;// // pred balanced[s: Board] {\r&#xA;// //   XTurn[s] or OTurn[s]\r&#xA;// // }\r&#xA;\r&#xA;// // // run { all b: Board | wellformed[b] and balanced[b]} for exactly 1 Board \r&#xA;\r&#xA;// // // run {\r&#xA;// // //   all b : Board | {\r&#xA;// // //     wellformed[b]\r&#xA;// // //     balanced[b]\r&#xA;// // //     winner[b, X]\r&#xA;// // //   }\r&#xA;// // // } for exactly 1 Board\r&#xA;\r&#xA;// // pred move[pre: Board, post: Board, row: Int, col: Int, p: Player] {\r&#xA;// //   -- guard:\r&#xA;// //   no pre.board[row][col]   -- nobody\'s moved there yet\r&#xA;// //   p = X implies XTurn[pre] -- appropriate turn\r&#xA;// //   p = O implies OTurn[pre]  \r&#xA;// //   row &amp;gt;= 0 and row &amp;lt;= 2    -- row number is valid\r&#xA;// //   col &amp;gt;= 0 and col &amp;lt;= 2    -- column number is valid\r&#xA;  \r&#xA;// //   -- action:\r&#xA;// //   post.board[row][col] = p\r&#xA;// //   all row2: Int, col2: Int | ((row!=row2) or (col!=col2)) implies {        \r&#xA;// //      post.board[row2][col2] = pre.board[row2][col2]     \r&#xA;// //   }  \r&#xA;// // }\r&#xA;\r&#xA;// // // run {\r&#xA;// // //   some pre, post: Board | {\r&#xA;// // //     wellformed[pre]\r&#xA;// // //     not wellformed[post]\r&#xA;// // //     some row, col: Int, p: Player | {\r&#xA;// // //       move[pre, post, row, col, p]\r&#xA;// // //     }\r&#xA;// // //    }\r&#xA;// // // } for 2 Board\r&#xA;\r&#xA;\r&#xA;// // one sig Game {\r&#xA;// //   initialState: one Board,\r&#xA;// //   next: pfunc Board -&amp;gt; Board\r&#xA;// // }\r&#xA;\r&#xA;// // pred traces {\r&#xA;// //     -- The trace starts with an initial state\r&#xA;// //     starting[Game.initialState]\r&#xA;// //     no sprev: Board | Game.next[sprev] = Game.initialState\r&#xA;// //     -- Every transition is a valid move\r&#xA;// //     all s: Board | some Game.next[s] implies {\r&#xA;// //       some row, col: Int, p: Player |\r&#xA;// //         move[s, Game.next[s], row, col, p]\r&#xA;// //     }\r&#xA;// // }\r&#xA;\r&#xA;// // pred dummy[b: Int] {\r&#xA;// // 2 > 1\r&#xA; #Board = 7\r&#xA; b > 3\r&#xA;// // }\r&#xA;// // run {\r&#xA;// //   traces\r&#xA;// // } for exactly 10 Board for {next is linear}\r&#xA;"';
  const predicates = extractPredicates(content);

  const forgePredUtil = new ForgePredUtil(datum, 0);
  console.log('predicates:', predicates);
  const result = forgePredUtil.evaluatePredicate(predicates[predicates.length - 1]);
  console.log('result:', result);

  // const instanceIndex = 0;
  // // const forgeExpr = 'Board6.board[0][1]';
  // const forgeExpr = 'add[#Left, 1]';
  // const forgeUtil = new ForgeUtil(datum, instanceIndex);
  // const result = forgeUtil.evaluateExpression(forgeExpr);

  // console.log('evaluated expr result:', result);

  // return (
  //   <div>{result}</div>
  // )

  return (
    <LocalNextExpressionIdProvider>
      <VizConstructor datum={datum} />
      {/* <VisualizationGenerator datum={datum} /> */}
    </LocalNextExpressionIdProvider>
  );
};

export { JsonView };
